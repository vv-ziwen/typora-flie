# 目录：

![设计模式之间的关系](https://i.loli.net/2021/02/04/f1A34hnBkg8lrcF.jpg)

## 设计模式的六大原则

​		**1、开闭原则（Open Close Principle）**

- 开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

  **2、里氏代换原则（Liskov Substitution Principle）**

- 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

  **3、依赖倒转原则（Dependence Inversion Principle）**

- 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

  **4、接口隔离原则（Interface Segregation Principle）**

- 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

  **5、迪米特法则，又称最少知道原则（Demeter Principle）**

- 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

  **6、合成复用原则（Composite Reuse Principle）**

- 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。



## 1、单例模式

单例模式的优点：

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。
- 可以避免对资源的多重占用。
- 单例模式设置全局访问点，可以优化和共享资源的访问。


单例模式的缺点：

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。

- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。

- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

  

实例说明：

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
}
```



## 2、建造者模式

建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

1. 封装性好，构建和表示分离。
2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
3. 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。


其缺点如下：

1. 产品的组成部分必须相同，这限制了其使用范围。
2. 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。



场景描述：

用户申请分润后，进入流程审批，流程分为3步：

1、必须字段：申请ID + 流程阶段

2、可选字段：客户ID

3、阶段必须字段：

​		a-审核  

​			|- 审核意见

​			|- 审核备注

​			|_ 审核时间

​		b-打款  

​			|_ 打款时间

​		c-提现

​			|_ 提现时间



```java
package com.jimi.sim.model.bo.profit;

import lombok.Getter;
import lombok.ToString;

import java.util.Date;

/**
 * 分润状态
 * @author liwen
 * @date 2021-01-29
 * @since 1.0.0
 */
@Getter
@ToString
public class ProfitStatusBO implements Serializable {
     
    private static final long serialVersionUID = -1008800418307511238L;

    /**
     * 客户ID
     */
    private String accountId;
    /**
     * 申请ID
     */
    private String auditId;
    /**
     * 流程阶段
     */
    private Integer status;
    /**
     * 审核意见
     */
    private Integer auditAdvice;
    /**
     * 审核备注
     */
    private String auditRemark;
    /**
     * 审核时间
     */
    private Date auditTime;
    /**
     * 打款时间
     */
    private Date payTime;
    /**
     * 提现时间
     */
    private Date withdrawalTime;

    private ProfitStatusBO(Builder builder) {
        this.accountId = builder.accountId;
        this.auditId = builder.auditId;
        this.status = builder.status;
        this.auditAdvice = builder.auditAdvice;
        this.auditRemark = builder.auditRemark;
        this.auditTime = builder.auditTime;
        this.payTime = builder.payTime;
        this.withdrawalTime = builder.withdrawalTime;
    }

    public static class Builder {
        private String accountId;
        private String auditId;
        private Integer status;
        private Integer auditAdvice;
        private String auditRemark;
        private Date auditTime;
        private Date payTime;
        private Date withdrawalTime;
		
        /**
        * 必须字段
        */
        public Builder(String auditId, Integer status) {
            this.auditId = auditId;
            this.status = status;
        }

        /**
         * 审核
         */
        public Builder audit(Integer auditAdvice, String auditRemark, Date auditTime) {
            this.auditAdvice = auditAdvice;
            this.auditRemark = auditRemark;
            this.auditTime = auditTime;
            return this;
        }

        /**
         * 打款
         */
        public Builder pay(Date payTime) {
            this.payTime = payTime;
            return this;
        }

        /**
         * 提现
         */
        public Builder withdrawal(Date withdrawalTime) {
            this.withdrawalTime = withdrawalTime;
            return this;
        }
		
        /**
        * 可选字段
        */
        public Builder accountId(String accountId) {
            this.accountId = accountId;
            return this;
        }

        public ProfitStatusBO build() {
            return new ProfitStatusBO(this);
        }
    }
}
```

实现方式：

```java
// 审核
profitStatusBO = new ProfitStatusBO
		.Builder(auditId, ProfitConstant.AUDIT_STATUS.REFUSE.getCode())
        .audit(auditAdvice, auditRemark, new Date())
    	.build();

// 打款
ProfitStatusBO profitStatusBO = new ProfitStatusBO
		.Builder(auditId, ProfitConstant.AUDIT_STATUS.TO_WITHDRAW.getCode())
        .pay(new Date())
    	.build();

// 提现
ProfitStatusBO profitStatusBO = new ProfitStatusBO
		.Builder(auditId, ProfitConstant.AUDIT_STATUS.WITHDRAW.getCode())
    	.withdrawal(new Date())
    	.accountId(accountId)
    	.build();

```

## 3、策略模式

策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。
2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。


其主要缺点如下。

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
2. 策略模式造成很多的策略类，增加维护难度。



场景描述：如何简化代码中的if-else语句

### 优化方案 1：提前 return，去除不必要的 else

如果 if-else 代码块包含 return 语句，可以考虑通过提前 return，把多余 else 干掉，使代码更加优雅。

优化前：

```java
if(condition){    
    //doSomething
}else{    
    return;
}
```

优化后：

```java
if（!condition）{    
    return;
}

//doSomething
```



### 优化方案 2：使用条件三目运算符

使用条件三目运算符可以简化某些 if-else，使代码更加简洁，更具有可读性。

优化前：

```java
int  price;
if(condition){    
    price = 80;
}else{    
    price = 100;
}
```

优化后：

```java
int price = condition?80:100;
```



### 优化方案 3：使用枚举

优化前：

```java
String desc;
if ("jimi".equals(code)){
    desc = "几米卡";
} else if ("lx".equals(code)) {
    desc = "鎏信卡";
} else if ("st".equals(code)) {
    desc = "尚通卡";
} else {
    desc = "无效卡";
}
```

优化后：

```java
public enum CARD_TYPE {
    JIMI("jimi", "几米卡"),
    LX("lx", "鎏信卡"),
    ST("st", "尚通卡"),
    MOBILE("mobile", "移动卡");
    private final String code;
    private final String desc;

    public String getCode() {
        return code;
    }

    public String getDesc() {
        return desc;
    }

    CARD_TYPE(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }


    public static String getDesc(String code) {
        CARD_TYPE[] values = values();
        for (CARD_TYPE value : values) {
            if (value.getCode().equals(code)) {
                return value.getDesc();
            }
        }
        return null;
    }
}
```

调用方式：

```java
String desc = CARD_TYPE.getDesc(code)
```



### 优化方案4：使用 Optional

因为非空判断导致的 if-else 比较多，这时候你可以使用 java8 的 Optional 进行优化。

优化前：

```java
BigDecimal totalMoneyAll = A + B;
if (str != null) {    
    System.out.println(str);
} else {    
    System.out.println("Null");
}
```

优化后：

```java
Optional<String> strOptional = Optional.of("jay@huaxiao");
strOptional.ifPresentOrElse(System.out::println, () -> System.out.println("Null"));
```



### 优化方案5：策略模式+工厂模式

```java
if (jimi) {
    jimiSimCardService;
} else if (lx) {
    lxSimCardService;
} else if (st) {
    stSimCardService;
}
```

```java
package com.jimi.sim.framework.constant;

import com.jimi.sim.service.api.JimiApiServiceImpl;
import com.jimi.sim.service.common.JimiSimCardServiceImpl;
import com.jimi.sim.service.common.LxSimCardServiceImpl;
import com.jimi.sim.service.common.SimCardService;
import com.jimi.sim.service.common.StSimCardServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * SIM卡相关常量
 *
 * @author liwen
 * @date 2021-01-22
 * @since 1.0.0
 */
@Component
public class SimConstant {

    private static LxSimCardServiceImpl lxSimCardService;
    private static StSimCardServiceImpl stSimCardService;
    private static JimiSimCardServiceImpl jimiSimCardService;

    @Autowired
    public void setLxSimCardService(LxSimCardServiceImpl lxSimCardService) {
        SimConstant.lxSimCardService = lxSimCardService;
    }

    @Autowired
    public void setStSimCardService(StSimCardServiceImpl stSimCardService) {
        SimConstant.stSimCardService = stSimCardService;
    }

    @Autowired
    public void setJimiSimCardService(JimiSimCardServiceImpl jimiSimCardService){
        SimConstant.jimiSimCardService = jimiSimCardService;
    }

    /**
     * 卡商类型
     */
    public enum CARD_TYPE {
        /**
         * 几米卡
         */
        JIMI("jimi", "几米卡", jimiSimCardService),
        /**
         * 鎏信卡
         */
        LX("lx", "鎏信卡", lxSimCardService),
        /**
         * 尚通卡
         */
        ST("st", "尚通卡", stSimCardService),
        /**
         * 移动卡
         */
        MOBILE("mobile", "移动卡", null);
        
        private final String code;
        private final String desc;
        private final SimCardService simCardService;

        public String getCode() {
            return code;
        }

        public String getDesc() {
            return desc;
        }

        CARD_TYPE(String code, String desc, SimCardService simCardService) {
            this.code = code;
            this.desc = desc;
            this.simCardService = simCardService;
        }

        public SimCardService getSimCardService() {
            return simCardService;
        }

        public static String getDesc(String code) {
            CARD_TYPE[] values = values();
            for (CARD_TYPE value : values) {
                if (value.getCode().equals(code)) {
                    return value.getDesc();
                }
            }
            return null;
        }

        public static SimCardService apiService(String code) {
            CARD_TYPE[] values = values();
            for (CARD_TYPE value : values) {
                if (value.getCode().equals(code)) {
                    return value.getSimCardService();
                }
            }
            return null;
        }
    }
}
```



