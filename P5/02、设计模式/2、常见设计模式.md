## 概述

总体来说设计模式分为三大类：

**创建型模式**，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

**结构型模式**，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

**行为型模式**，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

其它两类：并发型模式和线程池模式。



## 创建型模式

### 1、工厂方法模式（Factory）

分类：简单工厂、静态工厂

实现： java.lang.Object#toString()、java.lang.Class#newInstance()

> 就是 **一个返回**具体对象的方法，而不是多个。
> 凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
> 大多数情况下，我们会选用第三种——静态工厂方法模式。



### 2、抽象工厂模式（Factory）

分类：抽象工厂

实现：java.util.Calendar#getInstance()

> 抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。



### 3、单例模式（Singleton）

分类：饿汉式、懒汉式、静态内部类、枚举

实现：java.lang.Runtime#getRuntime()

> 全局只有一个实例
> 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
> 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。



### 4、建造者模式（Builder）

实现：java.lang.StringBuilder#append()

> 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的



### 5、原型模式（Prototype）

分类：深复制、浅复制

实现：java.lang.Object#clone()

>该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
>一个原型类，只需要实现Cloneable接口，覆写clone方法，实现super.clone()方法。
>1、浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
>2、深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。



## 结构型模式

### 1、适配器模式（Adapter）

分类：类适配器、对象适配器、接口适配器

实现：java.util.Arrays#asList()

> 当希望将**一个类**转换成满足**另一个新接口**的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。



### 2、装饰器模式（Decorator）

实现：java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap

> 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口
>
> 优点：
> 1、需要扩展一个类的功能。
> 2、动态的为一个对象增加功能，而且还能动态撤销。
>
> 缺点：
> 产生过多相似的对象，不易排错！



### 3、代理模式（Proxy）

实现： java.lang.reflect.Proxy

> 代理模式就是多一个代理类出来，替原对象进行一些操作，使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
>
> 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
> 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
> 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。



### 4、外观模式（Facade）



>外观模式是为了解决类与类之间的依赖关系的。
>
>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！



### 5、桥接模式（Bridge）

实现：JDBC

> 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：**将抽象化与实现化解耦，使得二者可以独立变化**



### 6、组合模式（Composite）

实现：Map.putAll，List.addAll、Set.addAll

> 组合模式有时又叫**部分-整体**模式在处理类似树形结构的问题时比较方便



### 7、享元模式（Flyweight）

实现：valueOf(int)

> 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。



## 行为型模式

### 1、策略模式（Strategy）

实现：



### 2、模板方法模式（Template）

实现： java.util.Collections#sort()



### 3、观察者模式（Observer）

实现：java.util.EventListener



### 4、迭代器模式

实现： java.util.Iterator



### 5、责任链模式

实现：javax.servlet.Filter#doFilter()



### 6、命令模式

实现：java.lang.Runnable



### 7、备忘录模式

实现：



### 8、状态模式

实现：



### 9、访问者模式

实现：



### 10、中介者模式

实现：java.lang.reflect.Method#invoke()



### 11、解释器模式

实现：java.text.Format，java.text.Normalizer